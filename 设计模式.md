## 设计模式 [https://www.cnblogs.com/geek6/p/3951677.html]
### 原则
- 总原则：开闭原则
- 单一职责
- 里氏替换原则 父类出现的地方子类都可以出现
- 依赖倒置原则 面向接口编程而不是面向具体编程
- 接口隔离原则 接口中不能有多余的方法
- 迪米特法则(最小知道原则)
- 合成复用原则 尽可能使用组合、聚合，而不是继承

### 23种设计模式
- 5种创建模式 （不包括：简单工厂 分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。）
    - 工厂方法模式（Factory Method）
    - 抽象工厂模式：
    - 单例模式(多线程)
    - 建造者模式
    - 原型模式（Prototype）
- 7种结构模式 (适配器模式是起源)
    - 适配器模式 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。
        - 类适配器
        - 对象适配器
        - 接口适配器
    - 装饰模式 装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例
        - 场景
            - 需要扩展一个类的功能。
            - 动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）
        - 缺点
            - 缺点：产生过多相似的对象，不易排错！
    - 代理模式 代理模式就是多一个代理类出来，替原对象进行一些操作
        - 代理模式的应用场景：如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
            - 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
            - 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
    - 外观模式Facade 外观模式是为了解决类与类之家的依赖关系的,而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口
    - 桥接模式 ：将抽象化与实现化解耦，使得二者可以独立变化
    - 组合模式
    - 享元模式
- 11中关系模式
    - 父类、子类关系
        - 策略模式 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下：
        - 模板方法模式 就是指：一个抽象类中，有一个主方法，再定义1...n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用
    - 类、类关系
        - 观察者模式 ：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化
        - 迭代子模式（Iterator）
        - 责任链模式 有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。
        - 命令模式 命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开
    - 类的状态
        - 备忘录模式 
        - 状态模式 当对象的状态改变时，同时改变其行为
    - 通过中间类
        - 访问者模式 访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。
        - 中介者模式mediator 类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用                   
        - 解释器模式
                
       


        
    


       


